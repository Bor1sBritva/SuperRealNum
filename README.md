## Общее описание задания

Разработать класс, представляющий заданный тип данных (ТД). Класс должен включать в себя (если это необходимо и подходит по смыслу к ТД):

- Конструкторы (по умолчанию, с параметрами, копии);
- Деструктор;
- Функцию вывода на экран;
- Перегруженные операторы:
  - Оператор присваивания;
  - Бинарные арифметические (+, -, \*, /) с операндами ТД и ТД, ТД и базовый тип, базовый тип и ТД;
  - Арифметика с накоплением (+=,-=);
  - Унарные (++,--) в префиксной и постфиксной форме;
  - Логические (&lt;, &gt;, ==, != );
  - Операторы взятия элемента ( \[\] или () ) по номеру или ключу;
  - Операторы преобразования типа к любому базовому.

Написать головную программу, обеспечивающую проверку всех реализованных свойств и методов класса.

# Реализация

В ходе работы мы создали класс на языке программирования C++, который реализует пользовательский тип данных (User Defined Data) – «Супер-точные вычисления». Данный тип данных позволяет создавать переменные, способные хранить в себе дробные числа с точностью до 999 знаков после запятой, совершать арифметические операции над ними практически без потери точности и выводить их в консоль. Для реализации подобного решения были созданы три файла:

- Main.cpp – тестовый файл, содержащий в себе простую модель тестирования каждого метода класса поочерёдно;
- LongDouble.h – заголовочный файл, объявляющий все данные и методы класса;
- LongDouble.cpp – дополнительный файл, описывающий всю работу класса.

**Описание разработанного класса**

**Описание заголовочного файла «LongDouble.h»:**

Файл LongDouble.h является заголовочным файлом, содержащим в себе объявление класса, его данных, методов и функций, необходимых для его функционирования. В теле файла прописаны, помимо базовых модулей для функционирования программы, следующие элементы:

Объявление класса class LongDouble;

Данные класса sign – знак числа (есди sign == -1 – отрицательное, если sign == 1 – положительное), exponent – позиция точки в числе, вектор digits – целочисленный вектор, хранящий все цифры числа;

Объявление функций:

initFromString – инициализация типа данных из базового типа данных string;

normalize – нормализация числа, содержащего потенциально бесконечное количество «9» после запятой;

removeZeroes – удаление бесполезных нулей справа и слева в представлении числа.

Далее, в Public записаны все методы, присущие данному классу:

**Конструкторы:  
**1\. LongDouble() – конструктор по умолчанию, создающий пустое значение;  
2\. LongDouble(const LongDouble& x) – конструктор копирования;  
3\. LongDouble(long double value) – конструктор из БТД double;  
4\. LongDouble(const std::string& s) – конструктор из пользовательской строки string;  
5\. ~LongDouble() – деструктор.

**Перегруженные операторы:**

Логические операторы: >, &lt;, &gt;=, <=, ==, !=

Оператор присваивания: =

Арифметика: +, -, \*, /

Арифметика с накоплением: +=, -=

Унарные: ++obj, -- obj, obj++, obj—

Оператор вывода в консоль: <<

**Функции:  
**inverse – функция, возвращающее обратное (1/X) значение числа

abs – функция, возвращающая модуль числа

**Описание файла «LongDouble.cpp»:**

Описание всех методов и функций:

void initFromString(const string& s): функция принимает на вход стандартную строку. Сразу же создаётся index – индекс числа, с которым в данный момент работает функция. Далее проверяется первый символ строки – если он является знаком «-», то знак числа будет отрицательным, иначе положительным. Далее циклично проверяется, в каком месте числа находится знак «.», и эта позиция записывается в exponent, и параллельно с этим все цифры заносятся в массив цифр.

void removeZeroes(): функция проверяет вектор digits с начала и с конца и, пока не найдёт цифру. Отдельную от нуля. Все нулевые незначащие элементы удаляются из вектора.

void removeZeroes(): функция «пробегает» дробную часть числа и, если встречает потенциально бесконечную последовательность цифр «9», удаляет её и вместо неё прибавляет единицу.

LongDouble(): конструктор по умолчанию, который инициализирует число «0.0».

LongDouble(const LongDouble& x): конструктор копирования, который просто переносит все данные одного числа в другое.

LongDouble(long double value): конструктор с параметром, из целочисленного long double, который преобразует переменную long double в строку и далее реализует функцию initFromString.

LongDouble(const string& s): конструктор с параметром, из стандартной строки инициализирует переменную с помощью функции initFromString.

LongDouble& LongDouble::operator=(const LongDouble& x): перегрузка оператора присваивания. Сперва проверяет, чтобы число не было ссылкой на саму себя (не находилось в том же адресе в памяти), чтобы не делать лишние операции, затем присваивает данные исходного числа данным нового числа.

bool LongDouble::operator>(const LongDouble& x) const: перегрузка оператора «>». Сперва проверяет, чтобы знаки и положения точки в числах были одинаковыми. Далее создаются дополнительные элементы для сравнения и с их помощью оба числа «выравниваются» - если их длины оказываются разными, они приводятся к одинаковой длине и после поразрядно сравниваются, пока не найдётся несоответствие.

bool LongDouble::operator&lt;(const LongDouble& x) const: оператор «<» реализуется как обратный к оператору «&gt;». Операторы «>=», «<=» и «!=» реализуются похожим образом, и их представление опущено.

bool LongDouble::operator==(const LongDouble& x) const: оператор «==» поочерёдно сравнивает знак, положение точки и каждую цифру числа поразрядно и, если все три проверки успешны, возвращает true. Если на каком-то из этапов появляется несоответствие – false.

LongDouble LongDouble::operator-() const: оператор отрицания. Меняет знак числа на противоположный.

LongDouble LongDouble::operator+(const LongDouble& x) const: оператор сложения. Если знаки чисел равны, то сперва сравниваются положения точки и выбирается наибольшее, после числа «выравниваются» справа добавлением в начало вектора «0». После сравнивается итоговая длина и числа «выравниваются» слева добавлением в конец вектора «0». Длиной итогового числа выбирается длина изначально наибольшего числа + 1 (на случай, если при сложении первого разряда мы получим двухзначное число. Следующим функция поразрядно складывает оба числа, а если при сложении получается двухзначное число – реализуются переносы. В конце удаляются незначащие ноли функцией removeZeroes() и возвращается результат. Если правое число отрицательное – возвращается левое число –(–правое). Иначе возвращается правое – (–левое).

LongDouble LongDouble::operator-(const LongDouble& x) const: оператор вычитания. Для вычитания нам в первую очередь нужно выяснить, какое из чисел больше, чтобы вычитать уже из него. Далее правым становится большее число, а левым – меньшее, и реализуется вычитание. Логика вычитания та же, что и у сложения, но в «обратную сторону».

LongDouble LongDouble::operator\*(const LongDouble& x) const: оператор умножения. Для умножения двух чисел типа LongDouble функция сперва обозначает длину результата как сумму длин исходных чисел. Далее базовой арифметикой мы перемножаем знаки, складываем позиции точки и создаём для результата вектор общей длины, а потом перемножаем все цифры исходных чисел «в столбик». Так же, как и со сложением и вычитанием, функция переносит разряды, если при умножении получаются двухзначные числа, а в конце удаляет незначащие нули.

LongDouble LongDouble::operator/(const LongDouble& x) const: оператор деления. Для операции деления самым простым путём реализации было получение обратного для левого числа и умножение правого на левое. Данный метод реализуется через общедоступную функцию void invert(), которая будет описана далее. После такого «деления», функция проверяет, чтобы в результате не было «бесконечного» ряда девяток, и «обрезает» их, возвращая готовый результат.

Перегрузки операторов «+=», «-=» и всех унарных операторов реализуются через уже добавленные перегрузки.

LongDouble LongDouble::inverse() const: функция инвертирования числа (1/X). Первым делом проверяется, чтобы число было ненулевым, ведь в таком случае реализовалось бы деление на 0. После создаётся дубликат числа и число, которое мы и будем делить на исходное. Далее функция вычисляет количество цифр в целой части и вычисляет результат «деления». В конце этот результат записывается в дробную часть числа, и функция возвращает результат.

LongDouble LongDouble::abs() const: функция взятия модуля числа. Просто-напросто устанавливает знак числа положительным.

ostream& operator<<(ostream& os, const LongDouble& value): перегрузка оператора вывода в консоль. Если знак числа отрицательный – первым делом выводит знак «-». Далее проверяется, нулевая или нет целая часть числа. В случае, если она ненулевая, то сперва выводятся первые exponent знаков числа, либо нули, если экспонента больше количества цифр, либо «.», если экспонента меньше количества цифр, и далее – оставшиеся цифры.  
Если же экспонента нулевая, выводится «0.» и все цифры числа.  
если экспонента меньше нуля, то выводится «0.», exponent цифр «0» и после значащие цифры числа. В конце весь результат строки выводится в консоль.

**Файл «Main.cpp»**

В данном файле происходит проверка работы реализованного класса.

Сперва объявляются четыре переменные необходимого типа данных, задаются готовые значения переменных типа int и double для проверки всех операторов, а также переменная строчного типа и переменная типа double для пользовательского ввода.  
Пользователь вводит через консоль два вещественных числа. Первое число может иметь какую угодно точность, второе должно содержать не более 17 знаков, включая целую часть и знак «.», так как оно записывается в переменную типа double. Далее выводится текст для более простого понимания процесса тестирования и обозначения каждого этапа, и последовательно программа проверяет все модули реализованного класса, выводя результаты вычислений в консоль.
